<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<appendix id="features">
 <title>Conformité SQL</title>

 <para>
  Cette section explique dans quelle mesure <productname>PostgreSQL</productname>
  se conforme à la norme SQL en vigueur. Les informations qui suivent ne représentent pas
  une liste exhaustive de conformance, mais présentent les thèmes principaux
  utilement et raisonnablement détaillés.
 </para>

 <para>
  Le nom complet du standard SQL est ISO/IEC 9075 <quote>Database Language
   SQL</quote>. Le standard est modifié de temps en temps. La mise à jour
  la plus récente est apparue en 2011. La version 2011 version a la référence
  ISO/IEC 9075:2011, ou plus simplement SQL:2011. Les versions antérieures sont
  SQL:2008, SQL:2006, SQL:2003, SQL:1999 et SQL-92.
  Chaque version remplace la précédente. Il n'y a donc aucun mérite à revendiquer
  une compatibilité avec une version antérieure du standard.
 </para>

 <para>
  Le développement de <productname>PostgreSQL</productname> respecte le
  standard en vigueur, tant que celui-ci ne s'oppose pas aux fonctionnalités
  traditionnelles ou au bon sens. Un grand nombre des fonctionnalités
  requises par le standard SQL sont
  déjà supportées. Parfois avec une syntaxe ou un fonctionnement légèrement
  différents. Une meilleure compatibilité est attendue pour les prochaines
  versions.
 </para>

 <para>
  <acronym>SQL-92</acronym> définit trois niveaux de conformité&nbsp;:
  basique (<foreignphrase>Entry</foreignphrase>), intermédiaire
  (<foreignphrase>Intermediate</foreignphrase>) et complète
  (<foreignphrase>Full</foreignphrase>).
  La majorité des systèmes de gestion de bases
  de données se prétendaient compatibles au standard <acronym>SQL</acronym>
  dès lors qu'ils se conformaient au niveau Entry&nbsp;; l'ensemble
  des fonctionnalités des niveaux Intermediate et Full étaient, soit trop
  volumineux, soit en conflit avec les fonctionnalités implantées.
 </para>

 <para>
  À partir de <acronym>SQL99</acronym>, le standard SQL définit un
  vaste ensemble de fonctionnalités individuelles à la place des trois niveaux
  de fonctionnalités définis dans <acronym>SQL-92</acronym>. Une
  grande partie représente les fonctionnalités <quote>centrales</quote> que
  chaque implantation conforme de SQL doit fournir. Les fonctionnalités
  restantes sont purement optionnelles. Certaines sont regroupées au sein de
  <quote>paquetages</quote> auxquels une implantation peut se déclarer conforme.
  On parle alors de conformité à un groupe de fonctionnalités.
 </para>

 <para>
  Les versions standards commençant avec <acronym>SQL:2003</acronym> sont
  également divisé en parties.
  Chacune est connue par un pseudonyme. Leur numérotation n'est pas
  consécutive&nbsp;:

  <itemizedlist>
   <listitem><para>ISO/IEC 9075-1 Framework (SQL/Framework)</para><indexterm><primary>SQL/Framework</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-2 Foundation (SQL/Foundation)</para><indexterm><primary>SQL/Foundation</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-3 Call Level Interface (SQL/CLI)</para><indexterm><primary>SQL/CLI</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-4 Persistent Stored Modules (SQL/PSM)</para><indexterm><primary>SQL/PSM</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-9 Management of External Data (SQL/MED)</para><indexterm><primary>SQL/MED</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-10 Object Language Bindings (SQL/OLB)</para><indexterm><primary>SQL/OLB</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-11 Information and Definition Schemas (SQL/Schemata)</para><indexterm><primary>SQL/Schemata</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-13 Routines and Types using the Java Language (SQL/JRT)</para><indexterm><primary>SQL/JRT</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-14 XML-related specifications (SQL/XML)</para><indexterm><primary>SQL/XML</primary></indexterm></listitem>
  </itemizedlist>
 </para>

 <para>
  <productname>PostgreSQL</productname> couvre les parties 1, 2, 9, 11 et 14.
  La partie 3 est couverte par l'interface ODBC, et la partie 13 est couverte
  par le plugin PL/Java, mais une conformance exacte n'est pas actuellement
  vérifiée par ses composants. Il n'y a pas actuellement d'implantations des
  parties 4 et 10 pour <productname>PostgreSQL</productname>.
 </para>

 <para>
  PostgreSQL supporte la plupart des fonctionnalités majeures de SQL:2011. Sur
  les 179 fonctionnalités requises pour une conformité
  &laquo;&nbsp;centrale&nbsp;&raquo; complète (<foreignphrase>full Core
   conformance</foreignphrase>), PostgreSQL se conforme à plus de
  160. De plus, il existe une longue liste de
  fonctionnalités optionelles supportées. À la date de rédaction de ce
  document, aucune version de quelque système de gestion de bases de
  données que ce soit n'affiche une totale conformité au cœur de SQL:2011.
 </para>

 <para>
  Les deux sections qui suivent présentent la liste des
  fonctionnalités supportées par <productname>PostgreSQL</productname> et
  celle des fonctionnalités définies dans <acronym>SQL:2011</acronym> qui
  ne sont pas encore prises en compte. Ces deux listes sont
  approximatives&nbsp;: certains détails d'une fonctionnalité présentée comme
  supportée peuvent ne pas être conformes, alors que de grandes parties d'une
  fonctionnalité non supportée peuvent être implantées.
  La documentation principale fournit les informations précises sur ce qui est,
  ou non, supporté.
 </para>

 <note>
  <para>
   Les codes de fonctionnalité contenant un tiret sont des sous-fonctionnalités.
   Si une sous-fonctionnalité n'est pas supportée, la fonctionnalité
   elle-même sera déclarée non supportée, alors même que d'autres
   de ses sous-fonctionnalités le sont.
  </para>
 </note>

 <sect1 id="features-sql-standard">
  <title>Fonctionnalités supportées</title>

  <para>
   <informaltable>
    <tgroup cols="4">
     <colspec colnum="1" colwidth="0.6*"/>
     <colspec colnum="2" colwidth="0.6*"/>
     <colspec colnum="3" colwidth="1.8*"/>
     <colspec colnum="4" colwidth="1.0*"/>
     <thead>
      <row>
       <entry>Identifiant</entry>
       <entry>Paquetage</entry>
       <entry>Description</entry>
       <entry>Commentaire</entry>
      </row>
     </thead>

     &features-supported;

    </tgroup>
   </informaltable>
  </para>
 </sect1>

 <sect1 id="unsupported-features-sql-standard">
  <title>Fonctionnalités non supportées</title>

  <para>
   Les fonctionnalités suivantes définies dans <acronym>SQL:2011</acronym> ne
   sont pas implantées dans cette version de
   <productname>PostgreSQL</productname>. Dans certains cas, des fonctionnalités
   similaires sont disponibles.
   <informaltable>
    <tgroup cols="4">
     <colspec colnum="1" colwidth="0.6*"/>
     <colspec colnum="2" colwidth="0.6*"/>
     <colspec colnum="3" colwidth="1.8*"/>
     <colspec colnum="4" colwidth="1.0*"/>
     <thead>
      <row>

       <entry>Identifiant</entry>
       <entry>Paquetage</entry>
       <entry>Description</entry>
       <entry>Commentaire</entry>
      </row>
     </thead>

     &features-unsupported;

    </tgroup>
   </informaltable>
  </para>
 </sect1>

  <sect1 id="xml-limits-conformance">
   <title>Limites XML et conformité au SQL/XML</title>

   <indexterm>
    <primary>SQL/XML</primary>
    <secondary>limites et conformités</secondary>
   </indexterm>

   <para>
    Des révisions significatives des spécifications relatives au XML dans
    ISO/IEC 9075-14 (SQL/XML) ont été introduites avec SQL:2006.
    L'implémentation de <productname>PostgreSQL</productname> du type de
    données XML et des fonctions relatives suit largement l'édition 2003, avec
    quelques emprunts aux éditions ultérieures. En particulier&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Quand le standard actuel fournit une famille de types de données XML
       pour contenir un <quote>document</quote> ou un <quote>content</quote>
       dans des variants non typés ou typés XML Schema, et un type
       <type>XML(SEQUENCE)</type> pour contenir des parties arbitraires d'un
       contenu XML, <productname>PostgreSQL</productname> fournit le seul type
       <type>xml</type>, qui peut contenir <quote>document</quote> ou
       <quote>content</quote>. Il n'y a pas d'équivalent au type
       <quote>sequence</quote> du standard.
      </para>
     </listitem>

     <listitem>
      <para>
       <productname>PostgreSQL</productname> fournit deux fonctions
       introduites avec SQL:2006, mais des variantes qui utilisent le langage
       XPath 1.0, plutôt que XML Query comme indiqué dans le standard.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Cette section présente certaines des différences résultantes que vous
    pourriez rencontrer.
   </para>

   <sect2 id="functions-xml-limits-xpath1">
    <title>Les requêtes sont restreintes à XPath 1.0</title>

    <para>
     Les fonctions <productname>PostgreSQL</productname>
     <function>xpath()</function> et <function>xpath_exists()</function>
     requêtent des documents XML en utilisant le langage XPath.
     <productname>PostgreSQL</productname> fournit aussi les variantes XPath
     des fonctions standards <function>XMLEXISTS</function> et
     <function>XMLTABLE</function>, qui utilisent officiellement le langage
     XQuery. Pour toutes ces fonctions, <productname>PostgreSQL</productname>
     se base sur la bibliothèque <application>libxml2</application>, qui
     fournit seulement XPath 1.0.
    </para>

    <para>
     Il existe un lien fort entre le langage XQuery et XPath version 2.0 et
     ultérieures&nbsp;: toute expression qui est syntaxiquement valide et qui
     exécute avec succès dans les deux langages produit le même résultat (avec
     une exception mineure pour les expressions contenant des références
     numériques de caractères ou des références d'entités prédéfinies, que
     XQuery remplace avec le caractère correspondant alors que XPath les
     ignore). Mais il n'y a pas un tel lien entre ces langages et XPath
     1.0&nbsp;; il s'agissait d'un langage précédent et il diffère en de
     nombreux aspects.
    </para>

    <para>
     Il existe deux catégories de limitation à garder à l'esprit&nbsp;: la
     restriction de XQuery à XPath pour les fonctions spécifiées dans le
     standard SQL standard, et la restriction de XPath à version 1.0  pour les
     fonctions standards et spécifiques à
     <productname>PostgreSQL</productname>.
    </para>

    <sect3>
     <title>Restriction de XQuery à XPath</title>

     <para>
      Les fonctionnalités de XQuery en dehors de celles d'XPath incluent&nbsp;:

      <itemizedlist>
       <listitem>
        <para>
         Les expressions XQuery peuvent construire et rnevoyer de nouveaux
         n&oelig;uds XML, en plus de toutes les valeurs XPath possibles. XPath peut
         créer et renvoyer des valeurs des types atomiques (nombres, chaînes,
         et ainsi de suite) mais peut seulement renvoyer des n&oelig;uds XML qui
         étaient déjà présents dans les documents fournis en entrée de
         l'expression.
        </para>
       </listitem>

       <listitem>
        <para>
         XQuery a des constructions de contrôle pour l'itération, le tri et le
         regroupement.
        </para>
       </listitem>

       <listitem>
        <para>
         XQuery permet la déclaration et l'utilisation de fonctions locales.
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <para>
      Les versions XPath récentes commencent à offrir des possibilités
      surchargeant celles-ci (comme <function>for-each</function> et
      <function>sort</function>, les fonctions anonymes, et
      <function>parse-xml</function> pour créer un n&oelig;ud à partir d'une
      chaîne), mais ces fonctionnalités n'étaient pas disponibles avant XPath
      3.0.
     </para>
    </sect3>

    <sect3 id="xml-xpath-1-specifics">
     <title>Restriction de XPath à 1.0</title>

     <para>
      Pour les développeurs familiers avec XQuery et XPath 2.0 ou ultérieur,
      XPath 1.0 présente un certain nombre de différences&nbsp;:

      <itemizedlist>
       <listitem>
        <para>
         Le type fondamental d'une XQuery/XPath, la <type>sequence</type>, qui
         peut contenir des n&oelig;uds XML, des valeurs atomiques, ou les deux,
         n'existe pas dans XPath 1.0. Une expression 1.0 peut seulement
         produire un ensemble de n&oelig;uds (contenant zéro ou plus de n&oelig;uds
         XML), ou une simple valeur atomique.
        </para>
       </listitem>

       <listitem>
        <para>
          Contrairement à une séquence XQuery/XPath, qui peut contenir tout
          élément désiré dans un ordre désiré, un ensemble de n&oelig;uds XPath 1.0
          n'offre pas de garantie d'ordre et, comme tout ensemble, n'autorise
          pas plusieurs apparences du même élément.
         <note>
          <para>
           La bibliothèque <application>libxml2</application> ne semble pas
           toujours renvoyer des ensembles de n&oelig;uds à
           <productname>PostgreSQL</productname> avec tous leurs membres dans
           le même ordre relatif au document en entrée. Sa documentation ne
           garantie pas ce comportement, et une expression XPath 1.0 ne permet
           pas de la contrôler.
          </para>
         </note>
        </para>
       </listitem>

       <listitem>
        <para>
         Alors que XQuery/XPath fournit tous les types définis dans un XML
         Schema et de nombreux opérateurs et fonctions sur ces types, XPath
         1.0 a seulement les ensembles de n&oelig;uds et les trois types atomiques
         <type>boolean</type>, <type>double</type> et <type>string</type>.
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0 n'a pas d'opérateur conditionnel. Toute expression
         XQuery/XPath telle que <literal>if ( hat ) then hat/@size else "no
         hat"</literal> n'a pas d'équivalent XPath 1.0.
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0 n'a pas d'opération de comparaison de tri pour les chaînes.
         <literal>"cat" &lt; "dog"</literal> et <literal>"cat" &gt;
         "dog"</literal> sont faux parce que ce sont des comparaisons
         numériques de deux valeurs <literal>NaN</literal>. Par contre,
         <literal>=</literal> and <literal>!=</literal> comparent les chaînes
         en tant que chaînes.
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0 brouille la distinction entre <firstterm>comparaisons de
         valeurs</firstterm> et <firstterm>comparaisons générales</firstterm>
         telles que XQuery/XPath les définit.<literal>sale/@hatsize =
         7</literal> et <literal>sale/@customer = "alice"</literal> sont des
         comparaisons quantifiées, vrai s'il existe au moins un 
         <literal>sale</literal> avec la valeur donnée pour l'attribut, mais
         <literal>sale/@taxable = false()</literal> est une comparaison de
         valeur pour la <firstterm>valeur booléenne réelle</firstterm> de
         l'ensemble complet de n&oelig;uds. C'est vrai uniquement si aucun
         <literal>sale</literal> n'a d'attribut <literal>taxable</literal>.
        </para>
       </listitem>

       <listitem>
        <para>
         Dans le modèle de données XQuery/XPath, un <firstterm>n&oelig;ud
         document</firstterm> peut avoir soit une forme document (exactement
         un élément de haut niveau, avec seulement des commentaires et des
         instructions de traitement en dehors) ou une forme contenu (avec ces
         contraintes diminuées). Son équivalent avec XPath 1.0, le
         <firstterm>n&oelig;ud racine</firstterm>, peut seulement être en forme
         document. C'est une des raisons pour lesquelles une valeur
         <type>xml</type> passée à l'élément de contexte pour toute fonction
         <productname>PostgreSQL</productname> basée sur XPath doit être dans
         une forme document.
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <para>
      Les différences soulignées ici ne sont pas complètes. Dans XQuery et les
      versions 2.0 et ultérieures de XPath, il existe un mode de compatibilité
      XPath 1.0, et les listes W3C des <ulink
      url='https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility'>modifications
      de fonctions</ulink> et des <ulink
      url='https://www.w3.org/TR/xpath20/#id-backwards-compatibility'>modifications
      de langage</ulink> appliqués dans ce mode offre une liste plus complète
      (bien que non exhaustive) des différences. Le mode de compatibilité ne
      peut pas rendre les nouveaux langages exactement équivalent à XPath 1.0.
     </para>
    </sect3>

    <sect3 id="functions-xml-limits-casts">
     <title>Correspondances entre les types de données SQL et XML et les valeurs</title>

     <para>
      Dans SQL:2006 et ultérieurs, les deux directions de conversion entre les
      types de données du standard SQL et les types XML Schema sont spécifiées
      précisément. Néanmoins, les règles sont exprimées en utilisant les types
      et sémantiques de XQuery/XPath, et n'ont pas d'application directe vers
      le modèle de données de XPath 1.0.
     </para>

     <para>
      Quand <productname>PostgreSQL</productname> fait une correspondance des
      valeurs de données SQL en XML (comme dans
      <function>xmlelement</function>), ou de XML vers SQL (comme dans les
      colonnes en sortie de <function>xmltable</function>), sauf pour quelques
      cas traités spécifiquement, <productname>PostgreSQL</productname>
      suppose simplement que la chaîne XPath 1.0 du type de données XML sera
      valide sous la forme textuelle du type de données SQL, et inversement.
      Cette règle a l'avantage de la simplicité tout en produisant pour de
      nombreux types de données des résultats similaires aux correspondances
      indiquées dans le standard. Dans cette version, une conversion explicite
      est nécessaire si une expression de colonne
      <function>xmltable</function> produit une valeur booléenne ou
      double&nbsp;; voir <xref linkend="functions-xml-limits-postgresql"/>.
     </para>

     <para>
      Quand l'interopérabilité avc d'autres systèmes est importante, pour
      certains types de données, il pourrait être nécessaire d'utiliser
      explicitement les fonctions de formatage des types de données (telles
      que celles disponibles dans <xref linkend="functions-formatting"/>) pour
      produire les correspondances standards.
     </para>
    </sect3>
   </sect2>

   <sect2 id="functions-xml-limits-postgresql">
    <title>
     Limites accidentelles de la mise en &oelig;uvre
    </title>

    <para>
     Cette section concerne les limites qui ne sont pas inhérentes à la bibliothèque
     <application>libxml2</application> mais s'appliquent à l'implémentation
     dans <productname>PostgreSQL</productname>.
    </para>

    <sect3>
     <title>
      Conversion nécessaire pour la colonne de type boolean ou double avec <function>xmltable</function>
     </title>

     <para>
      Une expression de colonne <function>xmltable</function> évaluée en un
      booléen ou nombre résultat XPath produira une erreur <quote>unexpected
      XPath object type</quote>. Le contournement reviendra à réécrire
      l'expression de colonne dans la fonction <function>string</function>
      XPath&nbsp;; <productname>PostgreSQL</productname> affectera alors la
      valeur chaîne à une colonne SQL en sortie, de type boolean ou double.
     </para>
    </sect3>

    <sect3>
     <title>
      Résultat du chemin de colonne ou colonne de résultat SQL d'un type XML
     </title>

     <para>
      Dans cette version, une expression de colonne
      <function>xmltable</function> qui évalue en un ensemble de n&oelig;uds XML
      peut être assignée à une colonne résultat SQL d'un type XML, produisant
      une concaténation de&nbsp;: pour la plupart des types de n&oelig;ud dans
      l'ensembl de n&oelig;uds, un n&oelig;ud texte contenant la <firstterm>valeur
      chaîne</firstterm> XPath 1.0 du n&oelig;ud, mais pour un n&oelig;ud élément, une
      copie du n&oelig;ud lui-même. Un tel ensemble de n&oelig;uds pourrait être affecté
      à une colonne SQL d'un type non XML seulement si l'ensmble de n&oelig;uds a
      un seul n&oelig;ud, avec la valeur textuelle de la plupart des n&oelig;uds types
      remplacée par une chaîne vide, la valeur textuelle d'un n&oelig;ud élément
      remplacée avec une concaténation de seulement ses n&oelig;uds enfants directs
      (excluant les descendants), et la valeur textuelle d'un n&oelig;ud texte ou
      attribut défini dans XPath 1.0. Une valeur textuelle XPath affectée à
      une colonne résultat d'un type XML doit être analysable comme du XML.
     </para>

     <para>
      Il est préférable de ne pas développer du code qui se base sur ces
      comportements, qui ont peu de ressemblances avec les spécifications, et
      sont changés dans <productname>PostgreSQL 12</productname>.
     </para>
    </sect3>

    <sect3>
     <title>Seul le mécanisme <literal>BY VALUE</literal> est supporté</title>

     <para>
      Le standard SQL définit deux <firstterm>mécanismes de
      passage</firstterm> qui s'appliquent lors du passage d'un argument XML
      du SQL vers une fonction XML ou recevant un résultat&nbsp;: <literal>BY
      REF</literal>, pour lequel une valeur XML particulière conserve son
      identité de n&oelig;ud, et <literal>BY VALUE</literal>, pour lequel le
      contenu du XML est passé mais l'identité du n&oelig;ud n'est pas préservée.
      Un mécanisme peut être indiqué avant une liste de paramètres, comme
      mécanisme par défaut pour tous, et après un paramètre pour surcharger le
      mécanisme par défaut.
     </para>

     <para>
      Pour illustrer la différence, si <replaceable>x</replaceable> est une
      valeur XML, ces deux requêtes produiront, respectivement, true et false
      dans un environnement SQL:2006&nbsp;:

<programlisting>
SELECT XMLQUERY('$a is $b' PASSING BY REF <replaceable>x</replaceable> AS a, <replaceable>x</replaceable> AS b NULL ON EMPTY);
SELECT XMLQUERY('$a is $b' PASSING BY VALUE <replaceable>x</replaceable> AS a, <replaceable>x</replaceable> AS b NULL ON EMPTY);
</programlisting>
     </para>

     <para>
      Dans cette version, <productname>PostgreSQL</productname> acceptera
      <literal>BY REF</literal> dans une construction
      <function>XMLEXISTS</function> ou <function>XMLTABLE</function>, mais
      l'ignorera. Le type de données <type>xml</type> détient une
      représentation textuelle sérialisée, donc il n'existe pas d'identité de
      n&oelig;ud à préserver. Le passage est donc forcément <literal>BY
      VALUE</literal>.
     </para>
    </sect3>

    <sect3>
     <title>Ne peut pas passer des paramètres nommés aux requêtes</title>

     <para>
      Les fonctions basées sur XPath supportent de passer un paramètre pour
      servir en tant que l'élément de contexte de l'expression XPath, mais ne
      supportent pas de valeurs supplémentaires dans l'expression, disponibles
      en tant que paramètres nommés.
     </para>
    </sect3>

    <sect3>
     <title>Aucun type <type>XML(SEQUENCE)</type></title>

     <para>
      Le type de données <type>xml</type> de
      <productname>PostgreSQL</productname> peut seulement détenir une valeur
      dans la forme <literal>DOCUMENT</literal> ou <literal>CONTENT</literal>.
      Un élément de contexte dans une expressions XQuery/XPath doit être un
      seul n&oelig;ud XML ou une valeur atomique, mais XPath 1.0 restreint cela
      encore plus au point que ce soit seulement un n&oelig;ud XML et qui n'a pas
      de type de n&oelig;ud permettant <literal>CONTENT</literal>. La conséquence
      est qu'un <literal>DOCUMENT</literal> bien formé est la seule forme de
      valeur XML que <productname>PostgreSQL</productname> peut fournir en
      tant qu'élément de contexte XPath.
     </para>
    </sect3>
   </sect2>
  </sect1>

</appendix>
